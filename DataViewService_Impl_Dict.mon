package com.apama.dataview;

/*
 * $Copyright(c) 2007-2011 Progress Software Corporation (PSC). All rights reserved.$
 * $Copyright (c) 2013-2016 Software AG, Darmstadt, Germany and/or Software AG USA Inc., Reston, VA, USA, and/or its subsidiaries and/or its affiliates and/or their licensors.$
 * Use, reproduction, transfer, publication or disclosure is prohibited except as specifically provided for in your License Agreement with Software AG
 */


/* This is an implementation of the Apama DataViewService API.
 *
 * You must first inject the "interface" - DataViewService_Interface.mon
 * Several implementations of the interface may exist. 
 * You may also need to inject optional "emitter" (see below).
 * Each implementation is in a separate file - inject the one you wish to use.
 *   e.g. this implementation is DataViewService_Impl_Dict.mon
 * 
 *
 * This service enables MonitorScript or JMon applications to expose a simple 
 * read-only "DataView" interface. DataViews may be viewed using Apama Dashboard 
 * Studio in a similar way to Scenarios.
*
 * Route vs. Send
 * The standard implementations of the DataViewService will always ROUTE 
 * any com.apama.dataview.* events, with the expectation that applications
 * using the service are co-located in the same correlator as the service.
 * If your architecture requires the client application to be in a separate 
 * correlator to the DataView service, then two "emitter" monitors are 
 * available.
 * DataViewService_ServiceEmitter.mon  would be injected into the same 
 * correlator as the DataView service after injecting the DataViewService 
 * interface but before injecting the implementation.
 * DataViewService_ApplicationEmitter.mon  would be injected into the same 
 * correlator as the client application after injecting the DataViewService 
 * interface but before injecting the client application.
 *
 * Notes:
 * 
 * 1) Every event has an initial field called msgId. Clients may choose to put 
 *    some identifier in this field when sending messages to the service. Any 
 *    event routed by the service in response will contain the same identifier.
 *
 * 2) Most events contain a field called "dvName". This string 
 *    uniquely identifies a DataView inside the correlator. 
 *
 * 3) Every event has a final field called extraParams that is a string:string
 *    dictionary. Some implementations may choose to use this field. It provides
 *    a way of future-proofing the interface to a certain extent.
 *
 * $Revision: 284562 $
 */

using com.apama.scenario.Create;
using com.apama.scenario.Delete;
using com.apama.scenario.Edit;
using com.apama.scenario.RequestInstancesDone;
using com.apama.scenario.RequestInstancesInternal;
using com.apama.scenario.Scenario;
using com.apama.scenario.ScenarioServiceUpdaterMultipleInstances;
using com.apama.scenario.ScenarioUnloaded;
using com.apama.scenario.StartScenarioRecovery;

// INTERNAL API CODE

monitor DataViewService_Impl_Dict {

	/** Internal event used to store instances/items in a DataView. */
	event _Item {
		wildcard integer scenarioInstanceId;
		wildcard string owner;
		sequence<string> outputFields;
	}
	

	// MetaData relating to this specific implementation
	dictionary<string,string> implementationMetaData := {
		"implementation.package"       :"com.apama.dataview",
		"implementation.name"          :"DataViewService_Impl_Dict",
		"implementation.fileName"      :"DataViewService_Impl_Dict.mon",
		"implementation.vendor"        :"Apama",
		"implementation.version"       :"10.0.0.0.302163",
		"implementation.fullVersion"   :"rel/10.0.0.x@302163",
		"implementation.language"      :"MonitorScript"
	};

	
	// Variables needed in the parent monitor
	dictionary <string, string> dataViewNamesDictionary;  // scenarioId : dvName
	DataViewAddDefinition dvAddDefinition;

	// Variables required in the per-DataView spawned sub-monitor 
	string dvName;  // this is without the PREFIX (which is defined in the onload)
	string scenarioId; // this is with the PREFIX (which is defined in the onload)
	integer NUM_FIELDS;
	sequence<integer> compoundKeyIndexes; // the indexes of the fields which form the compound unique key of a _Item
	sequence<string> compoundKeyNames;    // the names of the fields which form the compound unique key of a _Item
	dictionary <string, integer> compoundKeyInstanceDictionary; // scenarioInstanceCompoundKey : scenarioInstanceId
	dictionary <integer, _Item> instancesDictionary; // scenarioInstanceId : _Item
	integer scenarioInstanceId := 0;
	
	// Defect 9762.  Space, semi-colon and tab in dvName must be escaped 
	dictionary<string, string> escapeCharMap := {" ":"_",		// space
	                                             ";":"$003b",	// semi-colon
	                                             "	":"$0009",	// tab
	                                             "\t":"$0009"	// tab
	                                            };
	dictionary <string, string> escapedDvNamesDictionary; // unescaped dvname : escaped dvname
	dictionary <string, string> escapedScenarioIdDictionary; // unescaped scenarioId : escaped scenarioId

	ScenarioServiceUpdaterMultipleInstances updater;
	
	
	//===================================================================================
	
	/** A default no-arg constructor for an internal _Item. */
	action createDefaultItem() returns _Item {
		return _Item( -1, "", new sequence<string> );
	}

	/** action to take a string and escape all characters appeared in the escapeCharMap dictionary
	 *
	 * @param s - the string to be escaped
	 * 
	 * @return escaped string.  The original string is returned if there is nothing to be escaped
	**/
	action escapeDvName(string s) returns string {
		integer i;
		string retString := s;
		string unEscapeChar;
		for unEscapeChar in escapeCharMap.keys() {
			retString := _escapeIt(retString, unEscapeChar, escapeCharMap[unEscapeChar]);
		}
		
		return retString;
	}
	
	/** internal recursive method to escape the passed in string s.  s will be scanned for the the 
	    unEscapeChar and if found, replaced that with the escapeChar param.  This process will continue
	    until all characters in s is scanned.
	**/
	action _escapeIt( string s, string unEscapeChar, string escapeChar ) returns string {
		
		if (s.find(unEscapeChar) = -1) {
			return s;
		}
		
		integer index := s.find(unEscapeChar);

		string rest := s.substring(index+1, s.length());
		string retString := s.substring(0, index) + escapeChar + _escapeIt(rest, unEscapeChar, escapeChar);
		
		return retString;
	}
	
	action getEscapedDvName( string rawDvName ) returns string {
		string s;

		// given the raw dvName, return the cached value
		if (escapedDvNamesDictionary.hasKey(rawDvName)) {
			return escapedDvNamesDictionary[rawDvName];
		}
		
		// not found, just return original string
		return rawDvName;
	}
	
	action getUnescapedDvName( string escapedDvName ) returns string {
		
		string s;
		for s in escapedDvNamesDictionary.keys() {
			if (escapedDvNamesDictionary[s] = escapedDvName) {
				return s;
			}
		}
		
		// not found, just return original string
		return escapedDvName;
	}
	
	action getEscapedScenarioId( string rawScenarioId ) returns string {
		string s;

		// given the raw scenarioId, return the cached value
		if (escapedScenarioIdDictionary.hasKey(rawScenarioId)) {
			return escapedScenarioIdDictionary[rawScenarioId];
		}
		
		// not found, just return original string
		return rawScenarioId;
	}
	
	action getUnescapedScenarioId( string escapedScenarioId ) returns string {
		
		string s;
		for s in escapedScenarioIdDictionary.keys() {
			if (escapedScenarioIdDictionary[s] = escapedScenarioId) {
				return s;
			}
		}
		
		// not found, just return original string
		return escapedScenarioId;
	}
	
	action convertToScenarioId( string in_dvName ) returns string {
		string PREFIX := "DV_";
		string out_scenarioId;
		
		// for now just prepend the prefix, but in future do more checks and escaping of the name
		out_scenarioId:=PREFIX+in_dvName;
		
		return out_scenarioId;
	}
	
	
	action onload() {
		log "DataViewService implementation loaded. MetaData: "+implementationMetaData.toString() at INFO;
		
		log "onload() - entered." at DEBUG;

		// Look for the event to define a new DataView
		on all DataViewAddDefinition():dvAddDefinition {
			string escapedDvName := escapeDvName(dvAddDefinition.dvName);
			
			// name must not be ""
			if (dvAddDefinition.dvName.length()=0) {
				string msg := "Invalid name for new DataView - length must be greater than zero.";
				log "onload().on_all_DataViewAddDefinition() - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string> );
				return;
			}
			
			//name can not start with MEMST (clashes with memorystore plugin)
			string MEMORY_STORE_PREFIX := "MEMST_";
			if (dvAddDefinition.dvName.find(MEMORY_STORE_PREFIX)=0) {
				string msg := "Invalid name for new DataView - Must not start with " + MEMORY_STORE_PREFIX;
				log "onload().on_all_DataViewAddDefinition() - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, dvAddDefinition.dvName, msg, new dictionary<string,string> );
				return;
			}
			
			
			// displayName must not be ""
			if (dvAddDefinition.dvDisplayName.length()=0) {
				string msg := "Invalid displayName for new DataView - length must be greater than zero.";
				log "onload().on_all_DataViewAddDefinition() - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string> );
				return;
			}
			
			// use the escaped dvName here.  Will save to the escapedDvNamesDictionary
			// when validation is passed

			// both dvName and scenarioId are escaped
			dvName:=escapedDvName;
			scenarioId:=convertToScenarioId(dvName);
			string rawScenarioId:=convertToScenarioId(dvAddDefinition.dvName);
			
			// Validate the params we were given...
			
			// Make sure this is not already present as a DataView or Scenario
			if dataViewNamesDictionary.hasKey(scenarioId) {
				string msg := "DataView name already exists";
				log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
				return;
			}
			
				
			// Make sure we were given more than zero field names and types
			if (0=dvAddDefinition.fieldNames.size() or 0=dvAddDefinition.fieldTypes.size()) {
				string msg := "There must be 1 or more fields. DataViewAddDefinition event supplied "+dvAddDefinition.fieldNames.size().toString() +" names, and "+dvAddDefinition.fieldTypes.size().toString()+" types.";
				log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
				return;
			}
			
			// Make sure we were not given any duplicate field names or emptystring field names
			dictionary<string,boolean> validNames := new dictionary<string,boolean>;
			string fName;
			for fName in dvAddDefinition.fieldNames {
				// check for name=""
				if (0=fName.length()) {
					string msg := "One of the supplied field names in a DataViewAddDefinition event is invalid. Field names must have a length greater than zero. The field names supplied were: "+dvAddDefinition.fieldNames.toString();
					log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
					route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
					return;					
				}
				// check for duplicates
				if (validNames.hasKey(fName)) {
					string msg := "One of the supplied field names in a DataViewAddDefinition event is a duplicate. Duplicate field name: \""+fName+"\". The field names supplied were: "+dvAddDefinition.fieldNames.toString();
					log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
					route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
					return;
				}
				validNames[fName] := true;
			}
			
			// Make sure we were given enough types for the field names
			if (dvAddDefinition.fieldNames.size() != dvAddDefinition.fieldTypes.size()) {
				string msg := "Each field name must have a corresponding type. DataViewAddDefinition event supplied "+dvAddDefinition.fieldNames.size().toString() +" names, and "+dvAddDefinition.fieldTypes.size().toString()+" types.";
				log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
				route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
				return;
			}
			
			// Make sure the type strings we were given represent valid scenario variable types
			dictionary<string,boolean> validTypes := {"string":true, "float":true, "integer":true, "boolean":true, "enumeration":true, "decimal":true};
			integer i := 0;
			string t;
			for t in dvAddDefinition.fieldTypes {
				if not validTypes.hasKey(t) {
					string msg := "One of the supplied field types in a DataViewAddDefinition event is invalid. The type supplied at index "+i.toString()+" was: \""+t+"\"";
					log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
					route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
					return;
				}
				i:=i+1;
			}

			compoundKeyIndexes := new sequence<integer>; // ensure it is ALWAYS reset
			compoundKeyNames := new sequence<string>; // ensure it is ALWAYS reset
			// if we've been given some optional key fields, then validate these
			if (dvAddDefinition.keyFields.size() > 0) {
				string k;
				for k in dvAddDefinition.keyFields {
					integer idx := dvAddDefinition.fieldNames.indexOf(k);
					if (-1 = idx) {
						string msg := "One of the supplied keyField field names in a DataViewAddDefinition event is invalid. The invalid keyField name supplied was: \""+k+"\". The keyField names supplied were: "+dvAddDefinition.keyFields.toString();
						log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
						route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
						return;						
					}
					if (-1 < compoundKeyIndexes.indexOf(idx)) {
						string msg := "A duplicate keyField field name was given in a DataViewAddDefinition event. Duplicate keyField name: \""+k+"\". The keyField names supplied were: "+dvAddDefinition.keyFields.toString();
						log "onload().on_all_DataViewAddDefinition() - \""+escapedDvName+"\" - "+msg at WARN;
						route DataViewException(dvAddDefinition.msgId, escapedDvName, msg, new dictionary<string,string>);
						return;												
					}
					compoundKeyIndexes.append(idx); // since it is valid, add the index to the set.
				}
				compoundKeyNames := dvAddDefinition.keyFields;
			}

			// all fields are validated, save the escapedDvName and associate the scenarioId with the escapedName (dvName is escaped already)
			escapedDvNamesDictionary.add(dvAddDefinition.dvName, dvName);
			escapedScenarioIdDictionary.add(rawScenarioId, scenarioId);
			
			dataViewNamesDictionary.add(scenarioId, dvName);
			log "onload().on_all_DataViewAddDefinition() - \""+dvAddDefinition.dvName+"\" - adding new DataView definition with name: \""+dvAddDefinition.dvName+"\", and exposed externally with scenarioId: \""+scenarioId+"\"" at INFO;
			log "onload().on_all_DataViewAddDefinition() - \""+dvAddDefinition.dvName+"\" - spawning initializeScenario()..." at DEBUG;
			spawn initializeScenario();

		}

		// look for requests to unload definitions and tidy up our records.
		// The actual (spawned) DataView *also* looks for this event and kills itself
		on all DataViewDeleteDefinition() as dvDeleteDefinition {
			string rawScenarioId := convertToScenarioId(dvDeleteDefinition.dvName);
			string escapedScenarioId := getEscapedScenarioId(rawScenarioId);
			if dataViewNamesDictionary.hasKey(escapedScenarioId) {
				log "onload().on_all_DataViewDeleteDefinition() - \""+dvDeleteDefinition.dvName+"\" - removing DataView from dictionary with DataView name: \""+dvDeleteDefinition.dvName+"\", and exposed externally with scenarioId: \""+rawScenarioId+"\"" at INFO;
				dataViewNamesDictionary.remove(escapedScenarioId);
				escapedDvNamesDictionary.remove(dvDeleteDefinition.dvName);  // key is unescapedDvName
				escapedScenarioIdDictionary.remove(rawScenarioId);  // key is unescapedScenarioId
			}
		}

		
		// Look for external (i.e. com.apama.scenario API events) to remove
		// existing scenarios from our list to ensure we're up to date.
		on all ScenarioUnloaded() as scenScenarioUnloaded {
			// the following if statement should never now eval to true, as the entry in the dictionary 
			// should always have been previously deleted by the DataViewDeleteDefinition (see above). Done for completeness.
			if dataViewNamesDictionary.hasKey(scenScenarioUnloaded.scenarioId) {
				string dvName := dataViewNamesDictionary[scenScenarioUnloaded.scenarioId];
				log "onload().on_all_ScenarioUnloaded() - \""+scenScenarioUnloaded.scenarioId+"\" - removing DataView from dictionary with DataView name: \""+dvName+"\", and exposed externally with scenarioId: \""+scenScenarioUnloaded.scenarioId+"\"" at INFO;
				dataViewNamesDictionary.remove(scenScenarioUnloaded.scenarioId);
				escapedDvNamesDictionary.remove(getUnescapedDvName(dvName));  // key is unescapedDvName
				escapedScenarioIdDictionary.remove(getUnescapedScenarioId(scenScenarioUnloaded.scenarioId));  // key is unescapedScenarioId
			}			
		}

		
		// Look for DataViewItem* events for DataView names that do not exist and route exception events
		on all unmatched DataViewAddItem() as unmatchedAddItem {
			string msg := "Unknown DataView name in a DataViewAddItem event";
			log "unmatched DataViewAddItem() - "+msg at WARN;
			route DataViewException(unmatchedAddItem.msgId, escapeDvName(unmatchedAddItem.dvName), msg, new dictionary<string,string>);
		}
		on all unmatched DataViewAddOrUpdateItem() as unmatchedAddOrUpdateItem {
			string msg := "Unknown DataView name in a DataViewAddOrUpdateItem event";
			log "unmatched DataViewAddOrUpdateItem() - "+msg at WARN;
			route DataViewException(unmatchedAddOrUpdateItem.msgId, escapeDvName(unmatchedAddOrUpdateItem.dvName), msg, new dictionary<string,string>);
		}
		on all unmatched DataViewUpdateItem() as unmatchedUpdateItem {
			string msg := "Unknown DataView name in a DataViewUpdateItem event";
			log "unmatched DataViewUpdateItem() - "+msg at WARN;
			route DataViewItemException(unmatchedUpdateItem.msgId, escapeDvName(unmatchedUpdateItem.dvName), unmatchedUpdateItem.dvItemId, msg, new dictionary<string,string>);
		}
		on all unmatched DataViewUpdateItemDelta() as unmatchedUpdateItemDelta {
			string msg := "Unknown DataView name in a DataViewUpdateItemDelta event";
			log "unmatched DataViewUpdateItemDelta() - "+msg at WARN;
			route DataViewItemException(unmatchedUpdateItemDelta.msgId, escapeDvName(unmatchedUpdateItemDelta.dvName), unmatchedUpdateItemDelta.dvItemId, msg, new dictionary<string,string>);
		}
		on all unmatched DataViewDeleteItem() as unmatchedDeleteItem {
			string msg := "Unknown DataView name in a DataViewDeleteItem event";
			log "unmatched DataViewDeleteItem() - "+msg at WARN;
			route DataViewItemException(unmatchedDeleteItem.msgId, escapeDvName(unmatchedDeleteItem.dvName), unmatchedDeleteItem.dvItemId, msg, new dictionary<string,string>);
		}
		on all unmatched DataViewDeleteAllItems() as unmatchedDeleteAllItems {
			string msg := "Unknown DataView name in a DataViewDeleteAllItems event";
			log "unmatched DataViewDeleteAllItems() - "+msg at WARN;
			route DataViewException(unmatchedDeleteAllItems.msgId, escapeDvName(unmatchedDeleteAllItems.dvName), msg, new dictionary<string,string>);
		}
		on all unmatched DataViewGetFieldLookup() as unmatchedLookup {
			string msg := "Unknown DataView name in a DataViewGetFieldLookup event";
			log "unmatched DataViewGetFieldLookup() - "+msg at WARN;
			route DataViewException(unmatchedLookup.msgId, escapeDvName(unmatchedLookup.dvName), msg, new dictionary<string,string>);
		}
		
		log "onload() - complete." at DEBUG;
	}


	//===================================================================================

	
	// This defines the behaviour for each DataView bridge scenario type
	action initializeScenario() {
		log "initializeScenario() - \""+dvName+"\" - entered (spawned with this action)." at DEBUG;
		updater.init(scenarioId, context.current());

		string SCENARIO_SERVICE_CHANNEL := "com.apama.scenario";
		Scenario scenario := new Scenario; // store the schema of the DataView

		// Build up the scenario definition event
		scenario.scenarioId := scenarioId;
		scenario.displayName := dvAddDefinition.dvDisplayName;
		scenario.description := dvAddDefinition.dvDescription;
		scenario.inputNames := [];
		scenario.inputTypes := [];
		scenario.inputConstraints := [];
		scenario.inputDefaults := [];
		scenario.outputNames := dvAddDefinition.fieldNames;
		scenario.outputTypes := dvAddDefinition.fieldTypes;
		scenario.executionMode := 0;
		scenario.extraParams := dvAddDefinition.extraParams;
		scenario.extraParams.add("isReadOnly", "true");
		scenario.extraParams.add("type", "dataview");
		NUM_FIELDS := scenario.outputTypes.size();
	
		// If we have dont have enough constraints then set default constraints for ALL inputs (ignore any we were given)
		// - no - don't need to do that - always ZERO INPUTS
		
		// If we have dont have enough default initial inputs set basic defaults for ALL inputs (ignore any we were given)
		// - no - don't need to do that - always ZERO INPUTS

		
		// Notify any client listeners when scenario loads
		route scenario;
		send scenario to SCENARIO_SERVICE_CHANNEL;
		route DataViewDefinition(dvAddDefinition.msgId, dvName, dvAddDefinition.dvDisplayName, dvAddDefinition.dvDescription, dvAddDefinition.fieldNames, dvAddDefinition.fieldTypes, dvAddDefinition.keyFields, new dictionary<string,string>);

		// Build the helper dictionaries
		initialiseFieldLookup(scenario, dvName);
		
		// Look for the request to delete this bridge type
		on DataViewDeleteDefinition(dvName = getUnescapedDvName(dvName)) as delDef {
			//Remove this bridge type
			// the "on unload" listener will generate the response.
			log "initializeScenario().on_DataViewDeleteDefinition() - \""+dvName+"\" - routing DataViewDefinitionDeleted/ScenarioUnloaded events..." at INFO;
			route DataViewDefinitionDeleted(delDef.msgId, dvName, new dictionary<string,string>);
			route ScenarioUnloaded(scenarioId);
			log "initializeScenario().on_DataViewDeleteDefinition() - \""+dvName+"\" - Killing the mthread for this DataView." at INFO;
			die;
		}

		// RequestInstances handling (dumps current state of all instances by sending Instance events)
		on all RequestInstancesInternal(scenarioId = scenarioId) as scenRequestInstances {
			log "initializeScenario().on_all_RequestInstances() - \""+scenarioId+"\" - received request for instances. Initiating recovery on for request messageId: "+scenRequestInstances.messageId.toString() at DEBUG;
			
			integer k;
			_Item item;
			for k in instancesDictionary.keys() {
				item := instancesDictionary[k];

				log "dvItemMThread().on_all_RequestInstances() - \""+scenarioId+":"+k.toString()+"\" - routing an Instance event for this DataView Item..." at DEBUG;

				if(scenRequestInstances.ownerFilter = false or 
				   scenRequestInstances.owner = item.owner or 
				   item.owner = "*") {
					updater.emitInstance(scenRequestInstances, item.scenarioInstanceId, item.owner, "RUNNING", new sequence<string>, item.outputFields);
				}
			}
			route RequestInstancesDone(scenarioId, scenRequestInstances.messageId);
		}
		
		// Look for the scenario recovery event and send out the definition of this Scenario/DataView. (remember we have spawned per Scenario)
		on all StartScenarioRecovery() {
			route scenario;
		}

		
		
		
		// ========= Listeners for Create/Delete/Edit/Update ==================
		
		
		// ####################################################################
		// ####################################################################	
		// CREATE
		// First if an instance is created via the scenario API (e.g. a dashboard)...
		on all Create(scenarioId = scenarioId) as scenCreate {
			log "initializeScenario().on_all_Create() - \""+scenarioId+"\" - Scenario instance create ignored - DataViewService does not handle incoming CREATE events from the ScenarioService." at WARN;
			emitNack(scenCreate.messageId, -1);
			return;
		}
		// ... secondly if it is created from the MonitorScript side of things
		on all DataViewAddItem(dvName = getUnescapedDvName(dvName)) as dvAddItem {
			log "initializeScenario().on_all_DataViewAddItem() - \""+dvName+"\" - " at DEBUG;
			addDataViewItem(dvAddItem);
		}
		
		
		// #########################################################
		// #########################################################
		// DELETE
		// From Scenario API - Ignore/Nack
		on all Delete(scenarioId=scenarioId) as scenDelete {
			log "initializeScenario().on_all_Delete() - \""+scenarioId+":"+scenDelete.scenarioInstanceId.toString()+"\" - Scenario instance delete ignored - DataViewService does not handle incoming DELETE events from the ScenarioService." at WARN;
			emitNack(scenDelete.messageId, scenDelete.scenarioInstanceId);
			return;
		}
		// From DataViewService API
		on all DataViewDeleteItem(dvName=getUnescapedDvName(dvName)) as dvDeleteItem {
			log "initializeScenario().on_all_DataViewDeleteItem() - \""+dvName+":"+dvDeleteItem.dvItemId.toString()+"\" - " at DEBUG;
			deleteDataViewItem(dvDeleteItem);
		}
		// From DataViewService API
		on all DataViewDeleteAllItems(dvName=getUnescapedDvName(dvName)) as dvDeleteAllItems {
			log "initializeScenario().on_all_DataViewDeleteAllItems() - \""+dvName+"\" - " at DEBUG;
			deleteAllDataViewItems(dvDeleteAllItems);
		}
		
		
		// #########################################################
		// #########################################################
		// EDIT
		// From Scenario API - Ignore/Nack
		on all Edit(scenarioId = scenarioId) as scenEdit {
			log "initializeScenario().on_all_Edit() - \""+scenarioId+":"+scenEdit.scenarioInstanceId.toString()+"\" - Scenario instance edit ignored - DataViewService does not handle incoming EDIT events from the ScenarioService." at WARN;
			emitNack(scenEdit.messageId, scenEdit.scenarioInstanceId);
			return;
		}

		
		// #########################################################
		// #########################################################
		// ADD OR UPDATE (full)
		// Forward the AddOrUpdates from the Monitor via this DataViewService to the Scenario API
		on all DataViewAddOrUpdateItem(dvName = getUnescapedDvName(dvName)) as dvAddOrUpdateItem {
			addOrUpdateDataViewItem(dvAddOrUpdateItem);
		}

		// #########################################################
		// #########################################################
		// UPDATE (full)
		// Forward the Updates from the Monitor via this DataViewService to the Scenario API
		on all DataViewUpdateItem(dvName = getUnescapedDvName(dvName)) as dvUpdateItem {
			updateFullDataViewItem(dvUpdateItem);
		}

		// #########################################################
		// #########################################################
		// UPDATE (delta) - an update containing only deltas
		// Forward the Updates from the Monitor via this DataViewService to the Scenario API
		on all DataViewUpdateItemDelta(dvName = getUnescapedDvName(dvName)) as dvUpdateItemDelta {
			updateDeltaDataViewItem(dvUpdateItemDelta);
		}
		
		// ####################################################################
		// ####################################################################
		log "initializeScenario() - \""+dvName+"\" - complete." at DEBUG;
	}
	
	
	//===================================================================================

	
	// Management Actions

	/** Build the fieldname-index lookup dictionary, and add a the DataViewGetFieldLookup listener. */
	action initialiseFieldLookup(Scenario theScenario, string dataViewName) {
		log "initialiseFieldLookup() - building the dictionary, and adding a the DataViewGetFieldLookup listener" at DEBUG;
		string s;
		integer count := 0;
		dictionary <string, integer> fieldLookupDictionary := new dictionary<string, integer>; // fieldName : index in sequence
		for s in theScenario.outputNames {
			fieldLookupDictionary.add(s, count);
			count := count + 1;
		}		


		// Look for requests for the helper lookup dictionaries and reply
		on all DataViewGetFieldLookup(dvName = getUnescapedDvName(dataViewName)) as lookupReq {
			log "initialiseFieldLookup().on_all_DataViewGetFieldLookup() - \""+dataViewName+"\" - routing DataViewFieldLookup event..." at DEBUG;
			route DataViewFieldLookup(lookupReq.msgId, dataViewName, fieldLookupDictionary, new dictionary<string,string>);
		}		
	}
	

	action generateInstanceDied(_Item item) {
		// this should only ever be called once, from deleteDataViewItem() or deleteAllDataViewItems(), so we no longer need a flag to says its been called.
		log "generateInstanceDied() - \""+scenarioId+":"+item.scenarioInstanceId.toString()+"\" - routing Died events." at DEBUG;
		updater.emitInstanceDied(item.scenarioInstanceId, item.owner);
	}
	
	
	//===================================================================================

	
	// Management Actions
	action onunload() {
		route DataViewServiceUnloaded( new dictionary<string,string> );
		log "DataViewService implementation unloaded." at INFO;
	}
	
	
	//===================================================================================

	/* Build the compound key from a COMPLETE sequence of values (i.e. not just the keyFields).
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromSeq(sequence<string> fieldValues) returns string {
		string key := "#";
		integer keyIndex;
		integer i:=0;
		if not (fieldValues.size() = NUM_FIELDS) {
			log "buildCompoundKeyfromSeq() - the given sequence of fields is the wrong size. Required: "+NUM_FIELDS.toString()+", Found: "+fieldValues.size().toString() at WARN;
			return "";
		}
		for keyIndex in compoundKeyIndexes {
			if (fieldValues.size() <= keyIndex) {
				log "buildCompoundKeyfromSeq() - the given sequence of fields does not contain a required keyField: "+compoundKeyNames[i]+", index: "+keyIndex.toString() at WARN;
				return "";
			}
			key := key + fieldValues[keyIndex]; 
			i:=i+1;
			if (compoundKeyIndexes.size() > i) {
				key := key +":";
			}
		}
		return key;
	}

	/* Build the compound key from a sequence of keyField values ONLY (i.e. just the keyFields).
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromKeySeq(sequence<string> keyFieldValues) returns string {
		string key := "#";
		string keyValue;
		integer i:=0;
		if not (keyFieldValues.size() = compoundKeyIndexes.size()) {
			log "buildCompoundKeyfromKeySeq() - the given sequence of keyFields is the wrong size. Required: "+compoundKeyIndexes.size().toString()+", Found: "+keyFieldValues.size().toString() at WARN;
			return "";
		}
		for keyValue in keyFieldValues {
			key := key + keyValue; 
			i:=i+1;
			if (compoundKeyIndexes.size() > i) {
				key := key +":";
			}
		}
		return key;
	}

	/* Build the compound key from a dictionary of fieldNAME<->fieldvalue. 
	 * The dictionary does not need to contain a complete set of fields, but must contain at least the keyFields.
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromDict(dictionary<string,string> fields) returns string {
		string key := "#"; // all keys will have this prefix
		string keyName;
		integer i:=0;
		for keyName in compoundKeyNames {
			if not (fields.hasKey(keyName)) {
				log "buildCompoundKeyfromDict() - the given dictionary does not contain a required keyField: "+keyName at WARN;
				return "";
			}
			key := key + fields[keyName];
			i:=i+1;
			if (compoundKeyIndexes.size() > i) {
				key := key +":";
			}
		}
		return key;
	}

	/* Build the compound key from a dictionary of fieldINDEX<->fieldvalue. 
	 * The dictionary does not need to contain a complete set of fields, but must contain at least the keyFields.
	 * The key will ALWAYS be > "".  "" indicates an error.
	 * For a single-field (non-compound) key, whose value is "", just return the prefix.
	*/
	action buildCompoundKeyFromIndexDict(dictionary<integer,string> fields) returns string {
		string key := "#"; // all keys will have this prefix
		integer keyIndex;
		integer i:=0;
		for keyIndex in compoundKeyIndexes {
			if not (fields.hasKey(keyIndex)) {
				log "buildCompoundKeyfromIndexDict() - the given dictionary does not contain a required keyField: "+compoundKeyNames[i]+", index: "+keyIndex.toString() at WARN;
				return "";
			}
			key := key + fields[keyIndex];
			i:=i+1;
			if (compoundKeyIndexes.size() > i) {
				key := key +":";
			}
		}
		return key;
	}
	
	
	/** Add a new DataViewItem to the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewAddItem.
	 * 
	 * @exception Routes a DataViewException event if the new Item cannot be added.
	 */
	action addDataViewItem(DataViewAddItem dvAddItem) {
		log "addDataViewItem() - \""+dvName+"\" - entered." at DEBUG;
		
		if (dvAddItem.fieldValues.size() != NUM_FIELDS) {
			string msg := "DataView addItem ignored - " + NUM_FIELDS.toString() + " output field(s) required but " + dvAddItem.fieldValues.size().toString() + " provided.";
			
			// dvName is escaped already
			log "addDataViewItem() - \""+dvName+"\" - " + msg at WARN;
			route DataViewException(dvAddItem.msgId, dvName, msg, new dictionary<string,string>);
			return;
		}

		_Item newItem := createDefaultItem();
		newItem.owner := dvAddItem.owner;
		newItem.outputFields := dvAddItem.fieldValues;
		
		// are we using the automatic compound key feature? If so we must generate the key and store it in a dictionary
		if (compoundKeyIndexes.size()>0) {
			// build the key
			string compoundKey := buildCompoundKeyFromSeq(newItem.outputFields);
			
			// dvName is escaped already
			log "addDataViewItem() - \""+dvName+"\" - compoundKey is: "+compoundKey at DEBUG;
			
			// do we already have an item with that key?
			if (compoundKeyInstanceDictionary.hasKey(compoundKey)) {
				// reject the new item - duplicate key
				string msg := "DataView addItem ignored - the DataView uses the keyFields feature and the new item clashes with an existing item.  The supplied values were: "+dvAddItem.fieldValues.toString();
				log "addDataViewItem() - \""+dvName+"\" - " + msg at WARN;
				route DataViewException(dvAddItem.msgId, dvName, msg, new dictionary<string,string>);
				return;
			}
			
			// add the new key to the dictionary to map it to the scenarioInstanceId(=dvItemId)
			compoundKeyInstanceDictionary.add(compoundKey, scenarioInstanceId);
		}
		
		//copy then increment the main instanceId counter
		newItem.scenarioInstanceId := scenarioInstanceId;
		scenarioInstanceId := scenarioInstanceId + 1;

		// store the newly created Item
		log "addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - storing Item..." at INFO;
		instancesDictionary.add(newItem.scenarioInstanceId, newItem);
	
		// Send Created/Added events to both the Scenario and DataViewService APIs
		// This ensures that the Application MonitorScript and the Components such as Dashboards see the new instance
		log "addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing Created/Added events..." at DEBUG;
		updater.emitCreated(-1, newItem.scenarioInstanceId, newItem.owner, "RUNNING", new sequence<string>, newItem.outputFields);
		
		log "addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing initial Update event for this Item..." at DEBUG;
		float timeStamp := dvAddItem.timeStamp;
		if (-1.0=timeStamp) {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(newItem.scenarioInstanceId, timeStamp, newItem.outputFields, newItem.owner);
		
		route DataViewItem(dvAddItem.msgId, dvName, newItem.scenarioInstanceId, newItem.owner, newItem.outputFields, new dictionary<string,string>);

		log "addDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - complete." at DEBUG;
	}
	
	
	/* Add a new DataViewItem to the current (spawned) DataView if it does not already exist, 
	 * or update it when it does exist. This will ONLY work when keyFields are used.
	 * Attempts to change the owner of an existing item will be rejected with a DataViewItemException.
	 *
	 * This action is called as a result of matching a DataViewAddOrUpdateItem.
	 * 
	 * @exception Routes a DataViewException event if the new Item cannot be added.
	 * @exception Routes a DataViewItemException event if the new Item attempts to change the owner of an existing item.
	 */
	action addOrUpdateDataViewItem(DataViewAddOrUpdateItem dvAddOrUpdateItem) {
		log "addOrUpdateDataViewItem() - \""+dvName+"\" - entered." at DEBUG;
		
		if (0=compoundKeyIndexes.size()) { 
			// this DataView does not use keyFields - error - The DataViewAddOrUpdateItem event is only valid for DataViews which use keyFields
			string msg := "DataViewAddOrUpdateItem event is only valid for DataViews which use keyFields";
			log "addOrUpdateDataViewItem() - \""+dvName+"\" - routing DataViewException event - "+msg at WARN;
			route DataViewException(dvAddOrUpdateItem.msgId, dvName, msg, new dictionary<string,string>);
			return;
		}

		if (dvAddOrUpdateItem.fieldValues.size() != NUM_FIELDS) {
			string msg := "DataView addOrUpdateItem ignored - " + NUM_FIELDS.toString() + " output field(s) required but " + dvAddOrUpdateItem.fieldValues.size().toString() + " provided.";
			log "addOrUpdateDataViewItem() - \""+dvName+"\" - " + msg at WARN;
			route DataViewException(dvAddOrUpdateItem.msgId, dvName, msg, new dictionary<string,string>);
			return;
		}

		_Item newItem := createDefaultItem();
		newItem.owner := dvAddOrUpdateItem.owner;
		newItem.outputFields := dvAddOrUpdateItem.fieldValues;
		
		// build the key
	
		string compoundKey := buildCompoundKeyFromSeq(newItem.outputFields);
		log "addOrUpdateDataViewItem() - \""+dvName+"\" - compoundKey is: "+compoundKey at DEBUG;
		
		// do we already have an item with that key?
		boolean alreadyExists := compoundKeyInstanceDictionary.hasKey(compoundKey);
		if (alreadyExists) {
			// Yes we found the key - so we're going to get the existing item and update it (after a couple of checks)
			integer itemId := compoundKeyInstanceDictionary[compoundKey];
			newItem.scenarioInstanceId := itemId; // copy the ID for use when we send out the update
			log "addOrUpdateDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields" at DEBUG;
			
			// Get the existing item
			_Item item := instancesDictionary[itemId];
			
			// Check the owner is not changed
			if (item.owner != newItem.owner) {
				// reject the new item - attempted to change OWNER
				string msg := "DataView addOrUpdateItem ignored - detected attempt to change the owner of an existing item.  Current owner: \""+item.owner+"\", attempted owner: \""+newItem.owner+"\"";
				log "addOrUpdateDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - " + msg at WARN;
				route DataViewItemException(dvAddOrUpdateItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			
			// Now we can make the change to the actual stored values
			item.outputFields := newItem.outputFields;
		}
		else {
			// No didn't find the key, so it must be new - add the new key to the dictionary to map it to the scenarioInstanceId(=dvItemId)
			compoundKeyInstanceDictionary.add(compoundKey, scenarioInstanceId);
			
			//copy then increment the main instanceId counter
			newItem.scenarioInstanceId := scenarioInstanceId;
			scenarioInstanceId := scenarioInstanceId + 1;

			// store the newly created Item
			log "addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - storing Item..." at INFO;
			instancesDictionary.add(newItem.scenarioInstanceId, newItem);
		
			// Send Created/Added events to both the Scenario and DataViewService APIs
			// This ensures that the Application MonitorScript and the Components such as Dashboards see the new instance
			log "addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing Created/Added events..." at DEBUG;
			updater.emitCreated(-1, newItem.scenarioInstanceId, newItem.owner, "RUNNING", new sequence<string>, newItem.outputFields);
		}

		// In either case (add or update), we now need to route the Update event
		log "addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - routing an Update event with the following field values:"+newItem.outputFields.toString() at DEBUG;
		float timeStamp := dvAddOrUpdateItem.timeStamp;
		if (-1.0=timeStamp) {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(newItem.scenarioInstanceId, timeStamp, newItem.outputFields, newItem.owner);
		
		if (not alreadyExists) {
		
			route DataViewItem(dvAddOrUpdateItem.msgId, dvName, newItem.scenarioInstanceId, newItem.owner, newItem.outputFields, new dictionary<string,string>);
		}

		// All done
		log "addOrUpdateDataViewItem() - \""+dvName+":"+newItem.scenarioInstanceId.toString()+"\" - complete." at DEBUG;
	}


	/** Delete an existing DataViewItem from the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewDeleteItem.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be deleted (not found, etc).
	 */
	action deleteDataViewItem(DataViewDeleteItem dvDeleteItem) {
		integer itemId := dvDeleteItem.dvItemId;
		string compoundKey;
		if (0<=itemId) { // an itemId was supplied
			if (not instancesDictionary.hasKey(itemId)) {
				string msg := "Unknown dvItemId: "+itemId.toString();
				log "deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
		}
		else { // no itemId supplied
			if (0=compoundKeyIndexes.size()) { 
				// this DataView does not use keyFields - error - must supply a dvItemId
				string msg := "A valid dvItemId must be supplied (this DataView does not use keyFields)";
				log "deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			if (dvDeleteItem.keyFields.size() != compoundKeyIndexes.size()) {
				// invalid number of keys supplied
				string msg := "Incorrect number of key fields supplied. Found "+dvDeleteItem.keyFields.size().toString()+", require "+compoundKeyIndexes.size().toString();
				log "deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}

			// build the key
			compoundKey := buildCompoundKeyFromKeySeq(dvDeleteItem.keyFields);
			if (0=compoundKey.length()) {
				// we get an error back from buildCompoundKey - most likely the key fields were not supplied
				string msg := "Invalid set of key fields supplied: "+dvDeleteItem.keyFields.toString();
				log "deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;								
			}
			
			
			// all valid - get the itemId from the dictionary
			if (not compoundKeyInstanceDictionary.hasKey(compoundKey)) {
				// we built a valid key, but no dvItem is currently known with that key
				string msg := "No DataViewItem could be found for the keyFields supplied: "+dvDeleteItem.keyFields.toString();
				log "deleteDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvDeleteItem.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			itemId := compoundKeyInstanceDictionary[compoundKey];
			log "deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields" at DEBUG;
			
			// remove that compound key
			compoundKeyInstanceDictionary.remove(compoundKey);
		}
		_Item item := instancesDictionary[itemId];

		// Tell everyone about Deletion
		generateInstanceDied(item);
		log "deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing Deleted events..." at DEBUG;
		updater.emitDeleted(-1, itemId, item.owner);
		if (dvDeleteItem.keyFields.size() != compoundKeyIndexes.size()) {
			// deleted using dvItemId, but this DataView is using keyFields, so we need to build the key to pass out in the Deleted event
			integer i := 0;
			while i < compoundKeyIndexes.size() {
				dvDeleteItem.keyFields.append( item.outputFields[compoundKeyIndexes[i]] );
				i := i + 1;
			}
		}
		route DataViewItemDeleted(dvDeleteItem.msgId, dvName, itemId, dvDeleteItem.keyFields, new dictionary<string,string>);
		log "deleteDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - removing Item..." at INFO;
		instancesDictionary.remove(itemId);
		
		//log "deleteDataViewItem() - instancesDictionary content after removal: "+instancesDictionary.toString() at DEBUG;
	}


	
	/** Delete all existing DataViewItems from the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewDeleteAllItems.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be deleted (not found, etc).
	 */
	action deleteAllDataViewItems(DataViewDeleteAllItems dvDeleteAllItems) {
		
		// Iterate all the items an delete each one
		integer itemId;
		_Item item;
		for itemId in instancesDictionary.keys() {
			item := instancesDictionary[itemId];
			// Tell everyone about Deletion
			generateInstanceDied(item);
			log "deleteAllDataViewItems() - \""+dvName+":"+itemId.toString()+"\" - routing Deleted events..." at DEBUG;
			updater.emitDeleted(-1, itemId, item.owner);
		}
		
		// Clear the dictionaries
		log "deleteAllDataViewItems() - \""+dvName+"\" - removing ALL Items..." at INFO;
		compoundKeyInstanceDictionary.clear();
		instancesDictionary.clear();

		route DataViewAllItemsDeleted(dvDeleteAllItems.msgId, dvName, new dictionary<string,string>);
		
		//log "deleteAllDataViewItems() - instancesDictionary content after removal: "+instancesDictionary.toString() at DEBUG;
	}


	/** Update ALL the field values of an existing DataViewItem in the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewUpdateItem.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be updated (not found, keyField clash, etc).
	 */
	action updateFullDataViewItem(DataViewUpdateItem dvupdate) {
		integer itemId := dvupdate.dvItemId;
		
		// first check the number of fields (this is required before some of the other checks)
		if (dvupdate.fieldValues.size()!= NUM_FIELDS) {
			string msg := "DataView updateItem ignored - " + NUM_FIELDS.toString() + " output field(s) required but " + dvupdate.fieldValues.size().toString() + " provided.";
			log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - " + msg at WARN;
			route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
			return;
		}

		string compoundKey := "";
		if (0>itemId) { // no itemId supplied
			if (0=compoundKeyIndexes.size()) { 
				// this DataView does not use keyFields - error - must supply a dvItemId
				string msg := "A valid dvItemId must be supplied (this DataView does not use keyFields)";
				log "updateFullDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			// build the key
			compoundKey := buildCompoundKeyFromSeq(dvupdate.fieldValues);
			log "updateFullDataViewItem() - \""+dvName+"\" - compoundKey: "+compoundKey at DEBUG;
			if (0=compoundKey.length()) {
				// we get an error back from buildCompoundKey - most likely the key fields were not supplied?
				string msg := "Unable to construct compound key from field values: "+dvupdate.fieldValues.toString();
				log "updateFullDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;								
			}
			
			// all valid - get the itemId from the dictionary
			if (not compoundKeyInstanceDictionary.hasKey(compoundKey)) {
				// we built a valid key, but no dvItem is currently known with that key
				string msg := "No DataViewItem could be found using the keyFields from the field values supplied: "+dvupdate.fieldValues.toString();
				log "updateFullDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			itemId := compoundKeyInstanceDictionary[compoundKey];
			log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields" at DEBUG;
		}
		
		// check if we have an Item with the (supplied or calculated) itemId
		if (not instancesDictionary.hasKey(itemId)) {
			string msg := "Unknown dvItemId: "+itemId.toString();
			log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg at WARN;
			route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);
			return;
		}
				
		_Item item := instancesDictionary[itemId];
		
		// IMPORTANT
		// check we have not altered a keyField value if this DataView is configured for their use!!
		if (0<compoundKeyIndexes.size()) {
			string existingCompoundKey := buildCompoundKeyFromSeq(item.outputFields);
			if (0=compoundKey.length()) {
				compoundKey := buildCompoundKeyFromSeq(dvupdate.fieldValues);
			}
			if not (compoundKey=existingCompoundKey) {
				string msg := "DataView updateItem ignored - It is not permitted to change the value of a keyField. The supplied values were: "+dvupdate.fieldValues.toString();
				log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvupdate.msgId, dvName, itemId, msg, new dictionary<string,string>);

				log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - existing compoundKey: \""+existingCompoundKey+"\", new compoundKey: \""+compoundKey+"\"" at DEBUG;
				
				return;				
			}
		}

		// Now we can make the change to the actual stored values
		integer i:=0;
		while(i<NUM_FIELDS) {
			item.outputFields[i] := dvupdate.fieldValues[i].clone();
			i:=i+1;
		}

		log "updateFullDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing an Update event with the following field values:"+item.outputFields.toString() at DEBUG;
		float timeStamp := dvupdate.timeStamp;
		if (-1.0=timeStamp) {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(item.scenarioInstanceId, timeStamp, item.outputFields, item.owner);
	}
	
	
	/** Update a SUBSET of the field values of an existing DataViewItem in the current (spawned) DataView.
	 * This action is called as a result of matching a DataViewUpdateItemDelta.
	 * 
	 * @exception Routes a DataViewItemException event if the Item cannot be updated (not found, keyField clash, etc).
	 */
	action updateDeltaDataViewItem(DataViewUpdateItemDelta dvdelta) {

		integer numberOfUpdatedFields := dvdelta.fieldValues.size() - compoundKeyIndexes.size();
		if (numberOfUpdatedFields=0) or (dvdelta.fieldValues.size()=0) {
			// empty delta
			log "updateDeltaDataViewItem() - \""+dvName+":"+dvdelta.dvItemId.toString()+"\" - empty delta - ignored. Delta field values: "+dvdelta.fieldValues.toString() at DEBUG;
			//route DataViewItemException(dvName, dvdelta.dvItemId, "Empty delta - ignored. Delta field values: "+dvdelta.fieldValues.toString(), new dictionary<string,string>);
			return;
		}
		
		integer itemId := dvdelta.dvItemId;
		string compoundKey := "";
		
		if (0>itemId) { // no itemId supplied
			if (0=compoundKeyIndexes.size()) { 
				// this DataView does not use keyFields - error - must supply a dvItemId
				string msg := "A valid dvItemId must be supplied (this DataView does not use keyFields)";
				log "updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			if (numberOfUpdatedFields<0) {
				// not enough dictionary items provided - must be at least the number of keyFields+1
				string msg := "Not enough delta field values provided. Must be at least number of keyFields +1 (="+ (compoundKeyIndexes.size()+1).toString() +"). Supplied delta field values: "+dvdelta.fieldValues.toString();
				log "updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;				
			}
			// build the key
			compoundKey := buildCompoundKeyFromIndexDict(dvdelta.fieldValues);
			log "updateDeltaDataViewItem() - \""+dvName+"\" - compoundKey: "+compoundKey at DEBUG;
			
			if (0=compoundKey.length()) {
				// we get an error back from buildCompoundKey - most likely the key fields were not supplied?
				string msg := "Unable to construct compound key from delta field values: "+dvdelta.fieldValues.toString();
				log "updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;								
			}
			
			// all valid - get the itemId from the dictionary
			if (not compoundKeyInstanceDictionary.hasKey(compoundKey)) {
				// we built a valid key, but no dvItem is currently known with that key
				string msg := "No DataViewItem could be found for the keyFields supplied: "+dvdelta.fieldValues.toString();
				log "updateDeltaDataViewItem() - \""+dvName+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			itemId := compoundKeyInstanceDictionary[compoundKey];
			log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - found dvItemId for keyFields" at DEBUG;
		}

		// check if we have an Item with the (supplied or calculated) itemId
		if (not instancesDictionary.hasKey(itemId)) {
			string msg := "Unknown dvItemId: "+itemId.toString();
			log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg at WARN;
			route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
			return;
		}
		
		//log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - content of delta: "+dvdelta.fieldValues.toString() at DEBUG;
		_Item item := instancesDictionary[itemId];
		integer k;
		sequence<string> tmpFields := item.outputFields.clone(); // take a copy of the current values
		for k in dvdelta.fieldValues.keys() {
			if (k<0 or k>=NUM_FIELDS) {
				string msg := "DataView updateItemDelta ignored - Invalid field index provided ("+k.toString()+") in the delta field values: "+dvdelta.fieldValues.toString();
				log "updateDeltaDataViewItem() - \""+dvName+"\" - " + msg at WARN;					
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);
				return;
			}
			// no need to check for duplicate indexs, as we're getting them out of a dictionary - by definition there can't be duplicate keys!

			tmpFields[k] := dvdelta.fieldValues[k]; // overwrite a specific value with a new value
		}
		
		// IMPORTANT
		// check we have not altered a keyField value if this DataView is configured for their use!!
		if (0<compoundKeyIndexes.size()) {
			string existingCompoundKey := buildCompoundKeyFromSeq(item.outputFields);
			if (0=compoundKey.length()) {
				compoundKey := buildCompoundKeyFromSeq(tmpFields);
			}
			if not (compoundKey=existingCompoundKey) {
				string msg := "DataView updateItemDelta ignored - It is not permitted to change the value of a keyField. The supplied values were: "+dvdelta.fieldValues.toString();
				log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing DataViewItemException event - "+msg at WARN;
				route DataViewItemException(dvdelta.msgId, dvName, itemId, msg, new dictionary<string,string>);

				log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - existing compoundKey: \""+existingCompoundKey+"\", new compoundKey: \""+compoundKey+"\"" at DEBUG;

				return;				
			}
		}

		// Now we can make the change to the actual stored values
		item.outputFields := tmpFields; // replace with the new updated set
		
		log "updateDeltaDataViewItem() - \""+dvName+":"+itemId.toString()+"\" - routing an Update event with the following field values: "+item.outputFields.toString() at DEBUG;
		float timeStamp := dvdelta.timeStamp;
		if (-1.0=timeStamp) {
			timeStamp:=currentTime;
		}
		updater.emitUpdate_time(item.scenarioInstanceId, timeStamp, item.outputFields, item.owner);
	}

	
	//===================================================================================

	
	
	// The ACKs and NACKs for the Scenario API and the Scenario Bridge API.	
	action emitAcknowledgement(integer messageId, _Item item) {
		updater.emitAcknowledgement(messageId, item.scenarioInstanceId, item.outputFields);
	}

	action emitNack(integer messageId, integer scenarioInstanceId) {
		updater.emitNack(messageId, scenarioInstanceId);
	}

}
